const WhatE1E15TellUs = () => {
  return (
    <section id="what-e1-e15-tell-us">
      <h2>What E1–E15 Tell Us</h2>
      
      <p>From core physics to deployment-ready architectures</p>
      
      <h3>E1–E3: Core Dialectic</h3>
      <p>
        Basic T→A→S works: adversarial critique exposes flaws, synthesis improves quality, structure forces reasoning before output
      </p>
      
      <h3>E4–E7: Scale & Quality</h3>
      <p>
        Council personas (Logician/Empiricist/Ethicist) improve critique depth. Multiple iterations enhance synthesis. Controlled generation maintains format consistency
      </p>
      
      <h3>E8–E11: Real-World Constraints</h3>
      <p>
        Kimi CLI provides teacher quality without API costs. LoRA fine-tuning preserves base model. SCU regularization prevents overfitting to small datasets. MLX runs efficiently on Apple Silicon
      </p>
      
      <h3>E12–E13: Production Ready</h3>
      <p>
        Batch size 4 optimizes speed/memory. Checkpoint every 100 steps balances safety/performance. Batch size 4 + max_seq_length 4096 fits in 16GB RAM
      </p>
      
      <h3>E14–E15: Deployment</h3>
      <p>
        adapters/ directory structure supports versioning. SCU metrics (DataBPT, ParamBPT, S-ratio) enable monitoring. Hierarchical Synthesis allows progressive reasoning
      </p>
      
      <p style={{ marginTop: 'var(--spacing-md)' }}>
        Together, E1–E15 show this isn't a clever prompt hack—it's a complete framework for adversarial reasoning that scales from single queries to production systems.
      </p>
    </section>
  )
}

export default WhatE1E15TellUs

